/*************************************************************************************************************************************
programa para establecer el tiempo de muestreo

compile with the command: gcc time.c rs232.c -Wall -Wextra -o2 -o time 

//--- no 
sudo gcc -Wall -o protocolo protocolo.c -lwiringPi
sudo gcc time.c rs232.c -lwiringPi -Wall -Wextra -o2 -o time
//--- 
colocar la linea para compilar 


en la raspberry se ejecuta un codigo que que se carga con est vuelta 

sudo g++ Control_Observador.cpp library/rs232.c library/MPU9250.cpp library/an_packet_protocol.c library/orientus_packets.c library/PCA9685.cpp library/I2Cdev.cpp library/gpio.cpp -fpermissive -Wall -Wextra -o2 -o PIDM1C++

**************************************************************************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <cmath>
#include <iostream>
//#include <unistd.h>
#include <Eigen/Dense>
#include <Eigen/LU>

#include <unistd.h>

#include "Control_Kalman_Yaw.hpp"				// Operation AHRS algoith
#include "library/rs232.h"					// libreria puerto Serial, descargada de url=// colocar
#include "library/MPU9250.h"					// librerias para usar la IMU,libreias de Navio || www.emlid.com
#include "library/an_packet_protocol.h"
#include "library/orientus_packets.h"

#define RADIANS_TO_DEGREES (180.0/M_PI)
#define DEGREES_TO_RADIANS (M_PI/180.0)

#define NAVIO_RCOUTPUT_1 3
#define NAVIO_RCOUTPUT_2 4
#define SERVO_MIN 0.540 /*mS*/
#define SERVO_MAX 2.40  /*mS*/

#include "library/gpio.h"
#include "library/PCA9685.h"

using namespace Navio;
using namespace Eigen;

//---------------------- Objects ----------------------------------------------------------------------

//----------------------- deficiniciones para la IMU --------------------------------------------------------------
an_decoder_t an_decoder;
an_packet_t *an_packet;

status_packet_t status_packet;
euler_orientation_packet_t euler_orientation_packet;
raw_sensors_packet_t raw_sensors_packet;
int bytes_received;
//------------------------------------------------------------------------------------------------------------------
float t_elapsed;
float Ts = 60000.0;
clock_t start,end;
double cpu_time_used;                               // valor en microsegundo 
int telemetria=0;
// ----------------------- variables para uso del los motores ------------------------------------------------------
float motor1,motor2;
int motor_1,motor_2;

float motor3,motor4;
int motor_3,motor_4;
// -----------------------------------------------------------------------------------------------------------------

//int pasos0,0,0,0,0,0,0,0,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
int pasos[1167]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99.7000000000000,99.4000000000000,99.1000000000000,98.8000000000000,98.5000000000000,98.2000000000000,97.9000000000000,97.6000000000000,97.3000000000000,97,96.7000000000000,96.4000000000000,96.1000000000000,95.8000000000000,95.5000000000000,95.2000000000000,94.9000000000000,94.6000000000000,94.3000000000000,94,93.7000000000000,93.4000000000000,93.1000000000000,92.8000000000000,92.5000000000000,92.2000000000000,91.9000000000000,91.6000000000000,91.3000000000000,91,90.7000000000000,90.4000000000000,90.1000000000000,89.8000000000000,89.5000000000000,89.2000000000000,88.9000000000000,88.6000000000000,88.3000000000000,88,87.7000000000000,87.4000000000000,87.1000000000000,86.8000000000000,86.5000000000000,86.2000000000000,85.9000000000000,85.6000000000000,85.3000000000000,85,84.7000000000000,84.4000000000000,84.1000000000000,83.8000000000000,83.5000000000000,83.2000000000000,82.9000000000000,82.6000000000000,82.3000000000000,82,81.7000000000000,81.4000000000000,81.1000000000000,80.8000000000000,80.5000000000000,80.2000000000000,79.9000000000000,79.6000000000000,79.3000000000000,79,78.7000000000000,78.4000000000000,78.1000000000000,77.8000000000000,77.5000000000000,77.2000000000000,76.9000000000000,76.6000000000000,76.3000000000000,76,75.7000000000000,75.4000000000000,75.1000000000000,74.8000000000000,74.5000000000000,74.2000000000000,73.9000000000000,73.6000000000000,73.3000000000000,73,72.7000000000000,72.4000000000000,72.1000000000000,71.8000000000000,71.5000000000000,71.2000000000000,70.9000000000000,70.6000000000000,70.3000000000000,70,69.7000000000000,69.4000000000000,69.1000000000000,68.8000000000000,68.5000000000000,68.2000000000000,67.9000000000000,67.6000000000000,67.3000000000000,67,66.7000000000000,66.4000000000000,66.1000000000000,65.8000000000000,65.5000000000000,65.2000000000000,64.9000000000000,64.6000000000000,64.3000000000000,64,63.7000000000000,63.4000000000000,63.1000000000000,62.8000000000000,62.5000000000000,62.2000000000000,61.9000000000000,61.6000000000000,61.3000000000000,61,60.7000000000000,60.4000000000000,60.1000000000000,59.8000000000000,59.5000000000000,59.2000000000000,58.9000000000000,58.6000000000000,58.3000000000000,58,57.7000000000000,57.4000000000000,57.1000000000000,56.8000000000000,56.5000000000000,56.2000000000000,55.9000000000000,55.6000000000000,55.3000000000000,55,54.7000000000000,54.4000000000000,54.1000000000000,53.8000000000000,53.5000000000000,53.2000000000000,52.9000000000000,52.6000000000000,52.3000000000000,52,51.7000000000000,51.4000000000000,51.1000000000000,50.8000000000000,50.5000000000000,50.2000000000000,49.9000000000000,49.6000000000000,49.3000000000000,49,48.7000000000000,48.4000000000000,48.1000000000000,47.8000000000000,47.5000000000000,47.2000000000000,46.9000000000000,46.6000000000000,46.3000000000000,46,45.7000000000000,45.4000000000000,45.1000000000000,44.8000000000000,44.5000000000000,44.2000000000000,43.9000000000000,43.6000000000000,43.3000000000000,43,42.7000000000000,42.4000000000000,42.1000000000000,41.8000000000000,41.5000000000000,41.2000000000000,40.9000000000000,40.6000000000000,40.3000000000000,40,39.7000000000000,39.4000000000000,39.1000000000000,38.8000000000000,38.5000000000000,38.2000000000000,37.9000000000000,37.6000000000000,37.3000000000000,37,36.7000000000000,36.4000000000000,36.1000000000000,35.8000000000000,35.5000000000000,35.2000000000000,34.9000000000000,34.6000000000000,34.3000000000000,34,33.7000000000000,33.4000000000000,33.1000000000000,32.8000000000000,32.5000000000000,32.2000000000000,31.9000000000000,31.6000000000000,31.3000000000000,31,30.7000000000000,30.4000000000000,30.1000000000000,29.8000000000000,29.5000000000000,29.2000000000000,28.9000000000000,28.6000000000000,28.3000000000000,28,27.7000000000000,27.4000000000000,27.1000000000000,26.8000000000000,26.5000000000000,26.2000000000000,25.9000000000000,25.6000000000000,25.3000000000000,25,24.7000000000000,24.4000000000000,24.1000000000000,23.8000000000000,23.5000000000000,23.2000000000000,22.9000000000000,22.6000000000000,22.3000000000000,22,21.7000000000000,21.4000000000000,21.1000000000000,20.8000000000000,20.5000000000000,20.2000000000000,19.9000000000000,19.6000000000000,19.3000000000000,19,18.7000000000000,18.4000000000000,18.1000000000000,17.8000000000000,17.5000000000000,17.2000000000000,16.9000000000000,16.6000000000000,16.3000000000000,16,15.7000000000000,15.4000000000000,15.1000000000000,14.8000000000000,14.5000000000000,14.2000000000000,13.9000000000000,13.6000000000000,13.3000000000000,13,12.7000000000000,12.4000000000000,12.1000000000000,11.8000000000000,11.5000000000000,11.2000000000000,10.9000000000000,10.6000000000000,10.3000000000000,10,9.70000000000000,9.40000000000001,9.10000000000001,8.80000000000000,8.50000000000000,8.20000000000000,7.90000000000001,7.60000000000001,7.30000000000000,7,6.70000000000000,6.40000000000001,6.10000000000001,5.80000000000000,5.50000000000000,5.20000000000000,4.90000000000001,4.60000000000001,4.30000000000000,4,3.70000000000000,3.40000000000001,3.10000000000001,2.80000000000000,2.50000000000000,2.20000000000000,1.90000000000001,1.60000000000001,1.30000000000000,1,0.700000000000003,0.400000000000006,0.100000000000009,-0.199999999999989,-0.499999999999986,-0.799999999999983,-1.09999999999998,-1.39999999999999,-1.69999999999999,-1.99999999999999,-2.29999999999998,-2.59999999999998,-2.89999999999999,-3.19999999999999,-3.49999999999999,-3.79999999999998,-4.09999999999998,-4.39999999999999,-4.69999999999999,-4.99999999999999,-5.29999999999998,-5.59999999999998,-5.89999999999999,-6.19999999999999,-6.49999999999999,-6.79999999999998,-7.09999999999998,-7.39999999999999,-7.69999999999999,-7.99999999999999,-8.29999999999998,-8.59999999999998,-8.89999999999999,-9.19999999999999,-9.49999999999999,-9.79999999999998,-10.1000000000000,-10.4000000000000,-10.7000000000000,-11.0000000000000,-11.3000000000000,-11.6000000000000,-11.9000000000000,-12.2000000000000,-12.5000000000000,-12.8000000000000,-13.1000000000000,-13.4000000000000,-13.7000000000000,-14.0000000000000,-14.3000000000000,-14.6000000000000,-14.9000000000000,-15.2000000000000,-15.5000000000000,-15.8000000000000,-16.1000000000000,-16.4000000000000,-16.7000000000000,-17.0000000000000,-17.3000000000000,-17.6000000000000,-17.9000000000000,-18.2000000000000,-18.5000000000000,-18.8000000000000,-19.1000000000000,-19.4000000000000,-19.7000000000000,-20.0000000000000,-20.3000000000000,-20.6000000000000,-20.9000000000000,-21.2000000000000,-21.5000000000000,-21.8000000000000,-22.1000000000000,-22.4000000000000,-22.7000000000000,-23.0000000000000,-23.3000000000000,-23.6000000000000,-23.9000000000000,-24.2000000000000,-24.5000000000000,-24.8000000000000,-25.1000000000000,-25.4000000000000,-25.7000000000000,-26.0000000000000,-26.3000000000000,-26.6000000000000,-26.9000000000000,-27.2000000000000,-27.5000000000000,-27.8000000000000,-28.1000000000000,-28.4000000000000,-28.7000000000000,-29.0000000000000,-29.3000000000000,-29.6000000000000,-29.9000000000000,-30.2000000000000,-30.5000000000000,-30.8000000000000,-31.1000000000000,-31.4000000000000,-31.7000000000000,-32.0000000000000,-32.3000000000000,-32.6000000000000,-32.9000000000000,-33.2000000000000,-33.5000000000000,-33.8000000000000,-34.1000000000000,-34.4000000000000,-34.7000000000000,-35.0000000000000,-35.3000000000000,-35.6000000000000,-35.9000000000000,-36.2000000000000,-36.5000000000000,-36.8000000000000,-37.1000000000000,-37.4000000000000,-37.7000000000000,-38.0000000000000,-38.3000000000000,-38.6000000000000,-38.9000000000000,-39.2000000000000,-39.5000000000000,-39.8000000000000,-40.1000000000000,-40.4000000000000,-40.7000000000000,-41.0000000000000,-41.3000000000000,-41.6000000000000,-41.9000000000000,-42.2000000000000,-42.5000000000000,-42.8000000000000,-43.1000000000000,-43.4000000000000,-43.7000000000000,-44.0000000000000,-44.3000000000000,-44.6000000000000,-44.9000000000000,-45.2000000000000,-45.5000000000000,-45.8000000000000,-46.1000000000000,-46.4000000000000,-46.7000000000000,-47.0000000000000,-47.3000000000000,-47.6000000000000,-47.9000000000000,-48.2000000000000,-48.5000000000000,-48.8000000000000,-49.1000000000000,-49.4000000000000,-49.7000000000000,-50.0000000000000,-50.3000000000000,-50.6000000000000,-50.9000000000000,-51.2000000000000,-51.5000000000000,-51.8000000000000,-52.1000000000000,-52.4000000000000,-52.7000000000000,-53.0000000000000,-53.3000000000000,-53.6000000000000,-53.9000000000000,-54.2000000000000,-54.5000000000000,-54.8000000000000,-55.1000000000000,-55.4000000000000,-55.7000000000000,-56.0000000000000,-56.3000000000000,-56.6000000000000,-56.9000000000000,-57.2000000000000,-57.5000000000000,-57.8000000000000,-58.1000000000000,-58.4000000000000,-58.7000000000000,-59.0000000000000,-59.3000000000000,-59.6000000000000,-59.9000000000000,-60.2000000000000,-60.5000000000000,-60.8000000000000,-61.1000000000000,-61.4000000000000,-61.7000000000000,-62.0000000000000,-62.3000000000000,-62.6000000000000,-62.9000000000000,-63.2000000000000,-63.5000000000000,-63.8000000000000,-64.1000000000000,-64.4000000000000,-64.7000000000000,-65.0000000000000,-65.3000000000000,-65.6000000000000,-65.9000000000000,-66.2000000000000,-66.5000000000000,-66.8000000000000,-67.1000000000000,-67.4000000000000,-67.7000000000000,-68.0000000000000,-68.3000000000000,-68.6000000000000,-68.9000000000000,-69.2000000000000,-69.5000000000000,-69.8000000000000,-70.1000000000000,-70.4000000000000,-70.7000000000000,-71.0000000000000,-71.3000000000000,-71.6000000000000,-71.9000000000000,-72.2000000000000,-72.5000000000000,-72.8000000000000,-73.1000000000000,-73.4000000000000,-73.7000000000000,-74.0000000000000,-74.3000000000000,-74.6000000000000,-74.9000000000000,-75.2000000000000,-75.5000000000000,-75.8000000000000,-76.1000000000000,-76.4000000000000,-76.7000000000000,-77.0000000000000,-77.3000000000000,-77.6000000000000,-77.9000000000000,-78.2000000000000,-78.5000000000000,-78.8000000000000,-79.1000000000000,-79.4000000000000,-79.7000000000000,-80.0000000000000,-80.3000000000000,-80.6000000000000,-80.9000000000000,-81.2000000000000,-81.5000000000000,-81.8000000000000,-82.1000000000000,-82.4000000000000,-82.7000000000000,-83.0000000000000,-83.3000000000000,-83.6000000000000,-83.9000000000000,-84.2000000000000,-84.5000000000000,-84.8000000000000,-85.1000000000000,-85.4000000000000,-85.7000000000000,-86.0000000000000,-86.3000000000000,-86.6000000000000,-86.9000000000000,-87.2000000000000,-87.5000000000000,-87.8000000000000,-88.1000000000000,-88.4000000000000,-88.7000000000000,-89.0000000000000,-89.3000000000000,-89.6000000000000,-89.9000000000000,-90.2000000000000,-90.5000000000000,-90.8000000000000,-91.1000000000000,-91.4000000000000,-91.7000000000000,-92.0000000000000,-92.3000000000000,-92.6000000000000,-92.9000000000000,-93.2000000000000,-93.5000000000000,-93.8000000000000,-94.1000000000000,-94.4000000000000,-94.7000000000000,-95.0000000000000,-95.3000000000000,-95.6000000000000,-95.9000000000000,-96.2000000000000,-96.5000000000000,-96.8000000000000,-97.1000000000000,-97.4000000000000,-97.7000000000000,-98.0000000000000,-98.3000000000000,-98.6000000000000,-98.9000000000000,-99.2000000000000,-99.5000000000000,-99.8000000000000,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,-100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int w=0;

unsigned long zz=0;


//float Kc1=19.1305,Kc2=0.7503;
//float Ki=-3.9074;
float angulo[4]={0.0,1.5708,3.1416,4.7124};
float espacio[4]={10.0,13.0,50.0,60.0};
int estado_ref=0.0;
int c=0.0;

float Xt=0.0;
float Wt=1.5;
float Yaw_ref=0.0;
float Xt_ref=0.0;
float Kt = 4; // valor por confirmar
float yaw_1=0.0;
float yaw2=0.0;
float w_der,w_iz;

float Ui_der,Ui_iz;
float Ui_1_der=0.0,Ui_1_iz=0.0;

float rev_vel=0.0;
float rev_theta=0.0;
float theta=0.0,theta_a=0.0,w_der_a=0.0,w_iz_a=0.0;

//float error_der,error_iz;
//float error_1_der=0.0,error_1_iz=0.0;

float Ut_der,Ut_iz;
float I_Der,I_Iz;

//---------------------------------------------------------------------------------------------------------------------------
// para el observador
float y_der=0.0,y_iz=0.0;
float y_1_der=0.0,y_1_iz=0.0;

float U_der,U_iz;
//float yhat_iz,yhat_der;
//-----------------------------------------------------------------------------------------------------------------------------------------
//variables para el filtro de kalman
float Q1=1.5;
float Q2=1.5;
float R1=0.5;
float R2=2.0;
float sample=0.0;
//--------------------------------------------------------------------------------------------------------------
unsigned char dato[50];
unsigned char aux[15];
unsigned char enviar[1]; //M
unsigned char recibir=78;//N
unsigned char inicio[1];
unsigned char inicio1[1];


int n=0;

//int nbuf=0;
unsigned char buf[1];

int	cont=0;
int 	a;
int n_cadena=0;
unsigned char buf_cadena[5050];

char buf_datos[250];
FILE *pFile;

int estado=0;
int estado_aux=0;
int i=0;
int cont_datos=0;
int cadena=0;
int entero[10];
int decimal[10];
int var=0;
int var1=0;
int var2=0;
int b=0;
int ubica;
int revisar;
// ----------- variables PID Motor Derecho -----------
float Kp_d=1.2;
float Ti_d=1.8;
float Td_d=0.0;

float Kp_i=1.2;
float Ti_i=1.8;
float Td_i=0.0;

float error_d=0.0;
float error_i=0.0;
float Ui_1_d=0.0;
float Ui_1_i=0.0;
float Ud_1_d=0.0;
float Ud_1_i=0.0;
float error_1_d=0.0;
float error_1_i=0.0;
float Up_d=0.0;
float Up_i=0.0;
float Ui_d=0.0;
float Ui_i=0.0;
float Ud_d=0.0;
float Ud_i=0.0;
float U_d=0.0;
float U_i=0.0;

//---------------------------------------------
int 	cport_nr=17,		// se define el puerto por el caual se conestara ver tabla en la libreria
	bdrate=115200;		// se define la velocidad de transferencia
int	cport_nr2=24,		// Arduino-Mega
	bdrate2=115200;
int	cport_nr3=16,		// 3DR-Telemtria
	bdrate3=57600;

char	mode[]={'8','N','1',0};
// ---------------- se empaqieta el archivo y se envia toda la variable tipo char dato.---------------


// -----------------------------------------------------------------------------------------------------------------
void conver_motor()
{
	if(motor_1==100){
		buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=49;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
	}
	else if(motor_1==-100){
		buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=49;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
	}
	else if(motor_1>=10 && motor_1<=99){
		aux[0]=(motor_1/10);
                aux[1]=(motor_1%10);
        buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[0];
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[1];
	}
	else if(motor_1>=0 && motor_1<=9){
		buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=48+motor_1;
	}
	else if(motor_1<=-10 && motor_1>=-99){
		motor_1=abs(motor_1);
		aux[0]=(motor_1/10);
        aux[1]=(motor_1%10);

		buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[0];
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[1];
	}
	else if(motor_1<=0 && motor_1>=-9){
		motor_1 = abs(motor_1);
		buf_datos[cont_datos-1]=84;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=48+motor_1;
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		while(1){
		}
	}

cont_datos++;

	if(motor_2==100){
		buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=49;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
	}
	else if(motor_2==-100){
		buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=49;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
		cont_datos++;
		buf_datos[cont_datos-1]=48;
	}
	else if(motor_2>=10&&motor_2<=99){
		aux[0]=(motor_2/10);
        aux[1]=(motor_2%10);
        buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[0];
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[1];
	}
	else if(motor_2>=0 &&motor_2<=9){
		buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=48+motor_2;
	}
	else if(motor_2<=-10&&motor_2>=-99){
		motor_2=abs(motor_2);
		aux[0]=(motor_2/10);
		aux[1]=(motor_2%10);

		buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[0];
		cont_datos++;
		buf_datos[cont_datos-1]=48+aux[1];
	}
	else if(motor_2<=0&&motor_2>=-9){
		motor_2=abs(motor_2);

		buf_datos[cont_datos-1]=85;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		buf_datos[cont_datos-1]=48+motor_2;
	}
	else{
		printf("Error no puede entrar  motor_2");
		while(1){
		}
	}
	cont_datos++;
	buf_datos[cont_datos-1]=90;

}
// -----------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------
void agrupar()
{						// n_cadena = RS232_PollComport(cport_nr2, buf_cadena,5050 );

	if(n_cadena>0){
		buf_cadena[n_cadena] = 0;

		// detectar toda la cadena Inicio A,termina con Z.
		for(i=0;i<n_cadena;i++){
			if(buf_cadena[i]==65){
				while(n_cadena>0){
				buf_datos[cont_datos]=buf_cadena[i];
				i++;
				cont_datos++;
				n_cadena--;

				// no creo que se del el caso!!!(se encuentra la Z finaliza la busqueda del paquete).
				if(buf_datos[cont_datos-1]==90){
					//cont_datos=0;
					n_cadena=0;
					cadena++;
					break;}
					}
			}
			else if(buf_cadena[i]==90){
				buf_datos[cont_datos]=buf_cadena[i];
				//cont_datos = 0;
				cadena++;}
			else{
				while(n_cadena>0){
				buf_datos[cont_datos]=buf_cadena[i];
				i++;
				cont_datos++;
				n_cadena--;
				// (se encuentra la Z finaliza la busqueda del paquete).
				if(buf_datos[cont_datos-1]==90){
					//cont_datos=0;
					n_cadena=0;
					cadena++;
					break;}
						}
				}
		}
		//---------------------------------------------------------------------------------------------------------------------
	}

}

void decodificar(){
	if(cadena>0)
		{
		// decodificador de datos empieza con la letra A.
		if(buf_datos[0]==65){

			for(cont=0;cont<cont_datos;cont++){
			var  = 0;
			var1 = 0;
			var2 = 0;
			if(buf_datos[cont] == 65 || buf_datos[cont] == 66 || buf_datos[cont] == 67 || buf_datos[cont] == 68 || buf_datos[cont] == 69 || buf_datos[cont] == 70  || buf_datos[cont] == 71 || buf_datos[cont] == 72 || buf_datos[cont] == 73 || buf_datos[cont] == 74)
			{
				ubica   = buf_datos[cont];
				cont++;
				revisar = buf_datos[cont];
				//printf("Valor de la variable que se ve %i\n",revisar);
				if(revisar==45){
					var2=1;
					cont++;
					revisar = buf_datos[cont];
				}
				else{
					//var2=0;
				}
				while(revisar>=48 && revisar<=57){
					entero[var]=buf_datos[cont]-48;
					var++;
					cont++;
					revisar = buf_datos[cont];
				}
				//printf("Revisar antes: %i\n",revisar);
				if(revisar == 46){

					cont++;
					decimal[0]=buf_datos[cont]-48;
					//printf("En lA 0: %i\n",decimal[0]);
					cont++;
					decimal[1]=buf_datos[cont]-48;

					//printf("En la 1: %i\n",decimal[1]);
				}

				switch(var){ 
				case 0:
				printf("Error del programa no puede dar esto,control c para salir...estas loco man ???????....................\n");
				while(1){
				}
				break;
				case 1: 
				motor1 = entero[0];

				if(decimal[0]==0 && decimal[1]==0)
					motor1 = motor1;
				else if(decimal[0]==0 && decimal[1]>0)
					motor1 = motor1+(0.01*decimal[1]);
				else if(decimal[0]>0 && decimal[1]==0)
					motor1 = motor1+(0.1*decimal[0]);
				else if(decimal[0]>0 && decimal[1]>0)
					motor1 = motor1+(0.01*(decimal[0]*10+decimal[1]));

				entero[0]=0;
				decimal[0]=0;
				decimal[1]=0;
				break;
				case 2: 
				motor1 = entero[0]*10+entero[1];

				if(decimal[0]==0 && decimal[1]==0)
					motor1 = motor1;
				else if(decimal[0]==0 && decimal[1]>0)
					motor1 = motor1+(0.01*decimal[1]);
				else if(decimal[0]>0 && decimal[1]==0)
					motor1 = motor1+(0.1*decimal[0]);
				else if(decimal[0]>0 && decimal[1]>0)
					motor1 = motor1+(0.01*(decimal[0]*10+decimal[1]));

				entero[0]=0;
				entero[1]=0;
				decimal[0]=0;
				decimal[1]=0;
				break;
				case 3:
				motor1 = entero[0]*100+entero[1]*10+entero[2];

				if(decimal[0]==0 && decimal[1]==0)
					motor1 = motor1;
				else if(decimal[0]==0 && decimal[1]>0)
					motor1 = motor1+(0.01*decimal[1]);
				else if(decimal[0]>0 && decimal[1]==0)
					motor1 = motor1+(0.1*decimal[0]);
				else if(decimal[0]>0 && decimal[1]>0)
					motor1 = motor1+(0.01*(decimal[0]*10+decimal[1]));

				entero[0]=0;
				entero[1]=0;
				entero[2]=0;
				decimal[0]=0;
				decimal[1]=0;
				break;
			}
			if(var2==1){
				motor1 = -motor1;
				var2=0;
			}


			printf("Valor algo %i = %.6f\n",ubica, motor1); //con %.2f muestra dos valores despues del punto.
			//motor1=0;
			if(ubica==65)
				motor_1=motor1; // derecho 
			if(ubica==66)
				motor_2=motor1; // motor IZquierdo
			if(ubica==68)
				I_Der=motor1;
			if(ubica==69)
				I_Iz=motor1;
			if(ubica==74)
				estado=motor1;
			if(ubica==71)
				w_iz=motor1;
			if(ubica==70)
				w_der=motor1;
			motor1=0;

			}
			}
			}

		else{
			printf("Error en la cadena ! N_N !\n");

		}
		printf("--------------------------------------------------------------------------------------------------------------------------------------------------------\n");
		printf("--------------------------------------------------------------------------------------------------------------------------------------------------------\n");

		//printf("Valor motor_derecho = %f\n", motor1); //con %.2f muestra dos valores despues del punto.
		//printf("Valor %i\n", valor[0]);  	
		}
}
// ----------------------------------------------------------------------------------------------------------------------------------
void unidad_IMU()
{
if ((bytes_received = RS232_PollComport(cport_nr, an_decoder_pointer(&an_decoder), an_decoder_size(&an_decoder))) > 0)
		{
			/* increment the decode buffer length by the number of bytes received */
			an_decoder_increment(&an_decoder, bytes_received);

			/* decode all the packets in the buffer */
			while ((an_packet = an_packet_decode(&an_decoder)) != NULL)
			{
				if(an_packet->id == packet_id_status)
				{
					if(decode_status_packet(&status_packet, an_packet) == 0)
					{
						printf("Status Packet:\n");
						printf("\tFilter Ready = %d\n", status_packet.filter_status.b.orientation_filter_initialised);
					}
				}
				else if (an_packet->id == packet_id_euler_orientation) /* system state packet */
				{
					/* copy all the binary data into the typedef struct for the packet */
					/* this allows easy access to all the different values             */
					if(decode_euler_orientation_packet(&euler_orientation_packet, an_packet) == 0)
					{
						printf("Euler Orientation Packet:\n");
						printf("\tRoll = %f, Pitch = %f, Yaw = %f\n", euler_orientation_packet.orientation[0] * RADIANS_TO_DEGREES, euler_orientation_packet.orientation[1] * RADIANS_TO_DEGREES, euler_orientation_packet.orientation[2] * RADIANS_TO_DEGREES);
					}
				}
				else if (an_packet->id == packet_id_raw_sensors) /* raw sensors packet */
				{
					/* copy all the binary data into the typedef struct for the packet */
					/* this allows easy access to all the different values             */
					if(decode_raw_sensors_packet(&raw_sensors_packet, an_packet) == 0)
					{
						printf("Raw Sensors Packet:\n");
						printf("\tAccelerometers X: %f Y: %f Z: %f\n", raw_sensors_packet.accelerometers[0], raw_sensors_packet.accelerometers[1], raw_sensors_packet.accelerometers[2]);
						printf("\tGyroscopes X: %f Y: %f Z: %f\n", raw_sensors_packet.gyroscopes[0] * RADIANS_TO_DEGREES, raw_sensors_packet.gyroscopes[1] * RADIANS_TO_DEGREES, raw_sensors_packet.gyroscopes[2] * RADIANS_TO_DEGREES);
						printf("\tTemperatura de la IMU: %f\n", raw_sensors_packet.imu_temperature);


					}
				}
				else
				{
					printf("Packet ID %u of Length %u\n", an_packet->id, an_packet->length);
				}

				/* Ensure that you free the an_packet when your done with it or you will leak memory */
				an_packet_free(&an_packet);
			}
		}	
}

//----------------------------------------------------------------------------------------------------------------------------------
void conver(float ax,float ay,float az,float gx,float gy,float gz,float ap,float ar,float aya)
{
	if(ax>999)
	ax=999;
	else if(ax<-999)
	ax=-999;

	if(ay>999)
        ay=999;
        else if(ay<-999)
        ay=-999;

	if(az>999)
        az=999;
        else if(az<-999)
        az=-999;

	if(gx>999)
        gx=999;
        else if(gx<-999)
        gx=-999;

	if(gy>999)
        gy=999;
        else if(gy<-999)
        gy=-999;

	if(gz>999)
        gz=999;
        else if(gz<-999)
        gz=-999;

	if(ap>999)
        ap=999;
        else if(ap<-999)
        ap=-999;

	if(ar>999)
        ar=999;
        else if(ar<-999)
        ar=-999;

	if(aya>999)
        aya=999;
        else if(aya<-999)
        aya=-999;

	int ax1,ay1,az1,gx1,gy1,gz1,ap1,ar1,aya1,aux;
	ax1=ax;
	ay1=ay;
	az1=az;
	gx1=gx;
	gy1=gy;
	gz1=gz;
	ap1=ap;
	ar1=ar;
	aya1=aya;

	//printf("se muestra el valor que se tiene en la varible flotante %f\n ",ax);
	//printf("se muestra el valor entera %i\n",ax1);


	if(ax1>999 || ay1>999 || az1>999 || ap1>999 || ar1>999 || aya1>999 || gx1>999 || gy1>999 || gz1>999 || ax1<-999 || ay1<-999 || az1<-999 || gx1<-999 || gy1<-999 || gz1<-999 || ap1<-999 || ar1<-999 || aya1<-999)
	{
		printf("el valor es mayor a 999 problema, parar el codigo que esto no puede pasar\n");
		// agregar la parte para envio por telemetria
		printf("ax1:%i ay1:%i az1:%i ap1:%i ar1:%i aya:%i gx1:%i gy1:%i gz1:%i ap1:%i ara:%i aya1:%i\n",ax1,ay1,az1,gx1,gy1,gz1,ap1,ar1,aya1);
		while(1)
		{

		}

	}
	if(ax1>=100){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ax1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax-ax1;
		ax=ax*10000;
		ax1=ax;
		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ax1<=-100){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ax1=abs(ax1);
		buf_datos[cont_datos-1]=48+(ax1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ax1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax1+ax;
		ax=ax*10000;
		ax1=ax;
		ax1=abs(ax1);
		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ax1>=10 && ax1<=99){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax-ax1;
		ax=ax*10000;
		ax1=ax;
		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ax1>=0 && ax1<=9 && ax>=0.0000){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax-ax1;
		ax=ax*10000;
		ax1=ax;

		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ax1<=-10 && ax1>=-99){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ax1=abs(ax1);
		buf_datos[cont_datos-1]=48+(ax1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ax1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax1+ax;
		ax=ax*10000;
		ax1=ax;
		ax1=abs(ax1);
		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ax1<=0 && ax1>=-9){
		buf_datos[cont_datos-1]=75;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ax1=abs(ax1);
		buf_datos[cont_datos-1]=48+(ax1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ax=ax1+ax;
		ax=ax*10000;
		ax1=ax;
		ax1=abs(ax1);
		aux=ax1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		// agregar la parte para envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(ay1>=100){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ay1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ay=ay-ay1;
		ay=ay*10000;
		ay1=ay;
		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ay1<=-100){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ay1=abs(ay1);
		buf_datos[cont_datos-1]=48+(ay1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ay1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ay=ay1+ay;
		ay=ay*10000;
		ay1=ay;
		ay1=abs(ay1);
		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ay1>=10 && ay1<=99){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		ay=ay-ay1;
		ay=ay*10000;
		ay1=ay;
		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ay1>=0 && ay1<=9 && ay>=0.0000){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ay=ay-ay1;
		ay=ay*10000;
		ay1=ay;

		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ay1<=-10 && ay1>=-99){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ay1=abs(ay1);
		buf_datos[cont_datos-1]=48+(ay1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ay1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ay=ay1+ay;
		ay=ay*10000;
		ay1=ay;
		ay1=abs(ay1);
		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ay1<=0 && ay1>=-9){
		buf_datos[cont_datos-1]=76;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ay1=abs(ay1);
		buf_datos[cont_datos-1]=48+(ay1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ay=ay1+ay;
		ay=ay*10000;
		ay1=ay;
		ay1=abs(ay1);
		aux=ay1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		// agregar la parte para envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(az1>=100){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((az1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		az=az-az1;
		az=az*10000;
		az1=az;
		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(az1<=-100){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		az1=abs(az1);
		buf_datos[cont_datos-1]=48+(az1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((az1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		az=az1+az;
		az=az*10000;
		az1=az;
		az1=abs(az1);
		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(az1>=10 && az1<=99){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		az=az-az1;
		az=az*10000;
		az1=az;
		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(az1>=0 && az1<=9 && az>=0.0000){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		az=az-az1;
		az=az*10000;
		az1=az;

		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(az1<=-10 && az1>=-99){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		az1=abs(az1);
		buf_datos[cont_datos-1]=48+(az1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(az1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		az=az1+az;
		az=az*10000;
		az1=az;
		az1=abs(az1);
		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(az1<=0 && az1>=-9){
		buf_datos[cont_datos-1]=77;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		az1=abs(az1);
		buf_datos[cont_datos-1]=48+(az1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		az=az1+az;
		az=az*10000;
		az1=az;
		az1=abs(az1);
		aux=az1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		// agregar la parte para envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(gx1>=100){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gx1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		gx=gx-gx1;
		gx=gx*10000;
		gx1=gx;
		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gx1<=-100){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gx1=abs(gx1);
		buf_datos[cont_datos-1]=48+(gx1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gx1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gx=gx1+gx;
		gx=gx*10000;
		gx1=gx;
		gx1=abs(gx1);
		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gx1>=10 && gx1<=99){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		gx=gx-gx1;
		gx=gx*10000;
		gx1=gx;
		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gx1>=0 && gx1<=9 && gx>=0.0000){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gx=gx-gx1;
		gx=gx*10000;
		gx1=gx;

		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gx1<=-10 && gx1>=-99){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gx1=abs(gx1);
		buf_datos[cont_datos-1]=48+(gx1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gx1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gx=gx1+gx;
		gx=gx*10000;
		gx1=gx;
		gx1=abs(gx1);
		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gx1<=0 && gx1>=-9){
		buf_datos[cont_datos-1]=78;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gx1=abs(gx1);
		buf_datos[cont_datos-1]=48+(gx1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gx=gx1+gx;
		gx=gx*10000;
		gx1=gx;
		gx1=abs(gx1);
		aux=gx1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrgx motor1");
		// agreggx la pgxte pgxa envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(gy1>=100){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gy1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy-gy1;
		gy=gy*10000;
		gy1=gy;
		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gy1<=-100){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gy1=abs(gy1);
		buf_datos[cont_datos-1]=48+(gy1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gy1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy1+gy;
		gy=gy*10000;
		gy1=gy;
		gy1=abs(gy1);
		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gy1>=10 && gy1<=99){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy-gy1;
		gy=gy*10000;
		gy1=gy;
		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gy1>=0 && gy1<=9 && gy>=0.0000){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy-gy1;
		gy=gy*10000;
		gy1=gy;

		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gy1<=-10 && gy1>=-99){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gy1=abs(gy1);
		buf_datos[cont_datos-1]=48+(gy1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gy1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy1+gy;
		gy=gy*10000;
		gy1=gy;
		gy1=abs(gy1);
		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gy1<=0 && gy1>=-9){
		buf_datos[cont_datos-1]=79;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gy1=abs(gy1);
		buf_datos[cont_datos-1]=48+(gy1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gy=gy1+gy;
		gy=gy*10000;
		gy1=gy;
		gy1=abs(gy1);
		aux=gy1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrgy motor1");
		// agreggy la pgyte pgya envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(gz1>=100){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gz1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		gz=gz-gz1;
		gz=gz*10000;
		gz1=gz;
		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gz1<=-100){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gz1=abs(gz1);
		buf_datos[cont_datos-1]=48+(gz1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((gz1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gz=gz1+gz;
		gz=gz*10000;
		gz1=gz;
		gz1=abs(gz1);
		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gz1>=10 && gz1<=99){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gz=gz-gz1;
		gz=gz*10000;
		gz1=gz;
		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gz1>=0 && gz1<=9 && gz>=0.0000){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gz=gz-gz1;
		gz=gz*10000;
		gz1=gz;

		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(gz1<=-10 && gz1>=-99){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gz1=abs(gz1);
		buf_datos[cont_datos-1]=48+(gz1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(gz1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gz=gz1+gz;
		gz=gz*10000;
		gz1=gz;
		gz1=abs(gz1);
		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(gz1<=0 && gz1>=-9){
		buf_datos[cont_datos-1]=80;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		gz1=abs(gz1);
		buf_datos[cont_datos-1]=48+(gz1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		gz=gz1+gz;
		gz=gz*10000;
		gz1=gz;
		gz1=abs(gz1);
		aux=gz1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrgz motor1");
		// agreggz la pgzte pgza envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(ap1>=100){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ap1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		ap=ap-ap1;
		ap=ap*10000;
		ap1=ap;
		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ap1<=-100){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ap1=abs(ap1);
		buf_datos[cont_datos-1]=48+(ap1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ap1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ap=ap1+ap;
		ap=ap*10000;
		ap1=ap;
		ap1=abs(ap1);
		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ap1>=10 && ap1<=99){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ap=ap-ap1;
		ap=ap*10000;
		ap1=ap;
		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ap1>=0 && ap1<=9 && ap>=0.0000){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ap=ap-ap1;
		ap=ap*10000;
		ap1=ap;

		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ap1<=-10 && ap1>=-99){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ap1=abs(ap1);
		buf_datos[cont_datos-1]=48+(ap1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ap1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ap=ap1+ap;
		ap=ap*10000;
		ap1=ap;
		ap1=abs(ap1);
		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ap1<=0 && ap1>=-9){
		buf_datos[cont_datos-1]=81;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ap1=abs(ap1);
		buf_datos[cont_datos-1]=48+(ap1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ap=ap1+ap;
		ap=ap*10000;
		ap1=ap;
		ap1=abs(ap1);
		aux=ap1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		// agregar la parte para envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(ar1>=100){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ar1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar-ar1;
		ar=ar*10000;
		ar1=ar;
		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ar1<=-100){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ar1=abs(ar1);
		buf_datos[cont_datos-1]=48+(ar1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((ar1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar1+ar;
		ar=ar*10000;
		ar1=ar;
		ar1=abs(ar1);
		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ar1>=10 && ar1<=99){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar-ar1;
		ar=ar*10000;
		ar1=ar;
		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ar1>=0 && ar1<=9 && ar>=0.0000){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar-ar1;
		ar=ar*10000;
		ar1=ar;

		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(ar1<=-10 && ar1>=-99){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ar1=abs(ar1);
		buf_datos[cont_datos-1]=48+(ar1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(ar1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar1+ar;
		ar=ar*10000;
		ar1=ar;
		ar1=abs(ar1);
		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(ar1<=0 && ar1>=-9){
		buf_datos[cont_datos-1]=82;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		ar1=abs(ar1);
		buf_datos[cont_datos-1]=48+(ar1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		ar=ar1+ar;
		ar=ar*10000;
		ar1=ar;
		ar1=abs(ar1);
		aux=ar1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entrar motor1");
		// agregar la parte para envio por telemetria


		while(1){
		}
	}
//-----------------------------------------------------------------------
cont_datos++;
if(aya1>=100){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aya1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;
		
		aya=aya-aya1;
		aya=aya*10000;
		aya1=aya;
		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(aya1<=-100){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		aya1=abs(aya1);
		buf_datos[cont_datos-1]=48+(aya1/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aya1%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		aya=aya1+aya;
		aya=aya*10000;
		aya1=aya;
		aya1=abs(aya1);
		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(aya1>=10 && aya1<=99){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		aya=aya-aya1;
		aya=aya*10000;
		aya1=aya;
		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(aya1>=0 && aya1<=9 && aya>=0.0000){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		aya=aya-aya1;
		aya=aya*10000;
		aya1=aya;

		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);

	}
	else if(aya1<=-10 && aya1>=-99){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		aya1=abs(aya1);
		buf_datos[cont_datos-1]=48+(aya1/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aya1%10);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		aya=aya1+aya;
		aya=aya*10000;
		aya1=aya;
		aya1=abs(aya1);
		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else if(aya1<=0 && aya1>=-9){
		buf_datos[cont_datos-1]=83;
		cont_datos++;
		buf_datos[cont_datos-1]=45;
		cont_datos++;
		aya1=abs(aya1);
		buf_datos[cont_datos-1]=48+(aya1);
		cont_datos++;
		buf_datos[cont_datos-1]=46;
		cont_datos++;

		aya=aya1+aya;
		aya=aya*10000;
		aya1=aya;
		aya1=abs(aya1);
		aux=aya1;

		buf_datos[cont_datos-1]=48+(aux/1000);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%1000)/100);
		cont_datos++;
		buf_datos[cont_datos-1]=48+((aux%100)/10);
		cont_datos++;
		buf_datos[cont_datos-1]=48+(aux%10);
	}
	else
	{
		printf("Error en  codigo no puede entraya motor1");
		// agregaya la payate payaa envio por telemetria

		while(1){
		}
	}
//-----------------------------------------------------------------------
	cont_datos++;
	buf_datos[cont_datos-1]=90;
}
void seguridad()
{

}


//-----------------------------------------------------------------------------------------------------------------------
int map(long x,long in_min,long in_max,long out_min,long out_max)
{
	return(x - in_min)*(out_max-out_min)/(in_max-in_min)+out_min;
}

/* retorna "a - b" en segundos */
double timeval_diff(struct timeval *a, struct timeval *b)
{
  return
    (double)(a->tv_sec + (double)a->tv_usec/1000000) - (double)(b->tv_sec + (double)b->tv_usec/1000000);
}

int main()
{
//------------- definicion de matrices para calculos de observador----
	MatrixXf G(2,2);
	G << 0.989448962818569,0.020483932016461,-0.669568138205662,0.517271756294979;
	VectorXf H(2);
	H << 0.013824611679569,0.893999145641896;
	MatrixXf Cd(2,2);
	Cd << 1,0,0,1;
        MatrixXf Dd(1,1);
	Dd << 0;
	MatrixXf K(2,2);
	K << 0.0,0.0,0.0,0.0;
	VectorXf xhat_iz(2);
	xhat_iz << 0.0,0.0;
	VectorXf xhat_der(2);
	xhat_der << 0.0,0.0;
	VectorXf x_es_der(2);
	x_es_der << 0.0,0.0;
	VectorXf x_es_iz(2);
	x_es_iz << 0.0,0.0;
	VectorXf yhat_der(1);
	yhat_der << 0.0;
	VectorXf yhat_iz(1);
	yhat_iz << 0.0;
	MatrixXf Q(2,2);
	Q << Q1,0.0,0.0,Q2;
	MatrixXf  R(2,2);
	R << R1,0.0,0.0,R2;
	MatrixXf P(2,2);
	P << 10.0,0.0,0.0,10.0;
	MatrixXf inversa(2,2);
	inversa << 0.0,0.0,0.0,0.0;
	VectorXf Yt_iz(2);
	Yt_iz << 0.0,0.0;
	VectorXf Yt_der(2);
	Yt_der << 0.0,0.0;
	MatrixXf eye(2,2);
	eye << 1.0,0.0,0.0,1.0;
	MatrixXf aux(2,2);
	aux <<0.0,0.0,0.0,0.0;
	//VectorXd Ki(2);
	MatrixXf Ki(2,2);
	Ki << 0.41,-1.1819,-0.3944,-1.2260; // ganadoras
	MatrixXf Kc(2,5);
	Kc << 10.3598,-2.3936,-69.3459,1.9706,0.1439,-1.5852,9.2878,57.6530,0.1452,2.1170; //ganadoras

	MatrixXf Yt_delta(5,1);
	Yt_delta << 0.0,0.0,0.0,0.0,0.0;
	MatrixXf Yt_1(5,1);
	Yt_1 << 5.18,5.33,0.0,2.25,2.45;

	MatrixXf Uk_s (2,1);
	Uk_s << 50.0,45.0;

	VectorXf Ref(2);
	Ref << 0.0,0.0;
	VectorXf Yt(5);
	Yt << 0.0,0.0,0.0,0.0,0.0;
	VectorXf error(2);
	error << 0.0,0.0;
	VectorXf error_1(2);
	error_1 << 0.0,0.0;
	VectorXf Ut(2);
	Ut << 0.0,0.0;
	VectorXf Ut_1(2);
	Ut_1 << 0.0,0.0;
	VectorXf Ut_S(2);
	Ut_S << 0.0,0.0;
	VectorXf Ui(2);
	Ui << 0.0,0.0;
	VectorXf Ui_1(2);
	Ui_1 << 0.0,0.0;

//	std::cout << "matrix G\n" << G <<std::endl;
//	std::cout << "matrix  H\n" << H <<std::endl;
//	std::cout << "matrix  Cd\n" << Cd <<std::endl;
//	std::cout << "matrix  Dd\n" << Dd <<std::endl;
//	std::cout << "matrix L\n" << L <<std::endl;
//	std::cout << "matrix  xhat_iz\n" << xhat_iz <<std::endl;
//	std::cout << "matrix  xhat_der\n" << xhat_der <<std::endl;
/*
	std::cout << "Yt\n" << Yt <<std::endl;
	std::cout << "error\n" << error <<std::endl;
	std::cout << "error_1\n" << error_1 <<std::endl;
while(1)
{


}
*/

//---------------- se inican valores variadores ----------------------
	static const uint8_t outputEnablePin = RPI_GPIO_27;
	Pin pin(outputEnablePin);
	if (pin.init()) {
		pin.setMode(Pin::GpioModeOutput);
		pin.write(0); /* drive Output Enable low */
	} else {
		fprintf(stderr, "Output Enable not set. Are you root?\n");
	}
	PCA9685 pwm;
	pwm.initialize();
	pwm.setFrequency(50);
	pwm.setPWMmS(NAVIO_RCOUTPUT_1, 1480.0/1000.0); // 1480 el variador esta en cero.
	pwm.setPWMmS(NAVIO_RCOUTPUT_2, 1480.0/1000.0);
//---------------- para calcualar el tiempo de muestreo ---------------
	struct timeval t_ini, t_fin;
	double secs;
//---------------- Se inicializa la IMU en la Navio+ ------------------
	MPU9250 imu;  // MPU9250
	AHRS	ahrs; // Mahony AHRS
	imu.initialize();
	float ax2,ay2,az2,gx2,gy2,gz2,mx2,my2,mz2;    //para leer datos
//--------------- Orientation data ------------------------------------
	float roll,pitch,yaw;
	float offset[3];
	float dt;
	dt = Ts/1000000.0;
	offset[0]=0;
	offset[1]=0;
	offset[2]=0;
        printf("Beginning Gyro calibration...\n");
        for(int w = 0; w<100; w++)
        {
                imu.getMotion6(&ax2, &ay2, &az2, &gx2, &gy2, &gz2);
                offset[0]=offset[0]+(-gx2*0.0175);
		offset[1]=offset[1]+(-gy2*0.0175);
		offset[2]=offset[2]+(-gz2*0.0175);
                usleep(10000);
		printf("Offsets are: %f %f %f valor = %i\n", gx2, gy2, gz2,w);
        }
        offset[0]=offset[0]/100.0;
        offset[1]=offset[1]/100.0;
        offset[2]=offset[2]/100.0;

        printf("Offsets are: %f %f %f\n", offset[0], offset[1], offset[2]);
        ahrs.setGyroOffset(offset[0], offset[1], offset[2]);
//----------- matrices para calibracion de la IMU/Magnetometro --------
        MatrixXd m(3,3);
        m << 8.765,-0.393,1.172,0.107,6.505,0.106,-0.332,-0.829,7.959;
        std::cout << "matrix = \n" << m << std::endl;

        VectorXd b(3);
        b << 11.101,59.707,-23.887;
        std::cout << "vector = \n" << b << std::endl;

        VectorXd calibrated(3);
        calibrated << 0.0,0.0,0.0;
        std::cout << "vector = \n" << calibrated << std::endl;

        VectorXd no_calibrated(3);
        no_calibrated <<0.0,0.0,0.0;
        std::cout << "vector = \n" << no_calibrated << std::endl;

/*

        MatrixXd m(3,3);
        m << 4.698,0.1,-0.229,0.071,6.026,0.087,1.198,-0.121,3.227;
        std::cout << "matrix = \n" << m << std::endl;

        VectorXd b(3);
        b << -6.397,44.085,-29.711;

        std::cout << "vector = \n" << b << std::endl;

        VectorXd calibrated(3);
        calibrated << 0.0,0.0,0.0;
        std::cout << "vector = \n" << calibrated << std::endl;

        VectorXd no_calibrated(3);
        no_calibrated <<0.0,0.0,0.0;
        std::cout << "vector = \n" << no_calibrated << std::endl;
*/
//---------------- Se verifican los puertos USB -----------------------
/*
if(RS232_OpenComport(cport_nr,bdrate,mode))
	{
	printf("no se puede abrir el puerto para la IMU, verificar puerto \n");
	exit(EXIT_FAILURE);
	return(0);
	}
*/
an_decoder_initialise(&an_decoder);

if(RS232_OpenComport(cport_nr2,bdrate2,mode))
	{
	printf("no se puede abror el puerto serial del arduino,Verificar puerto\n ");
	exit(EXIT_FAILURE);
	return(0);
	}

if(RS232_OpenComport(cport_nr3,bdrate3,mode))
	{
	printf("no se puede abrir el puerto de telemetria, verificar puerto\n");
	exit(EXIT_FAILURE);
	return(0);
	}


//---------------------------------------------------------------------
#ifdef _WIN32
	Sleep(5000);
#else
	usleep(5000000);
#endif

motor1=0.00;
motor2=0.00;
w=0;

while(1)
{

	//------ funcion para garantizar el tiempo de muestreo, rx,tx+proces ----------
	gettimeofday(&t_ini, NULL); // inicio del contador
	//start = clock();
	//--------------------- se establece funcion para guardar datos en USB --------
	printf("valor de estado_aux %i\n",estado_aux);
	if(estado_aux==1){
	pFile=fopen("/media/ROVER_4/rover_rc.txt","w");
	estado_aux=2;
	c=0;
	}
	if(estado_aux==3){
	pFile=fopen("/media/ROVER_4/rover_auto.txt","w");
	estado_aux=4;
	sample=0;
	w=0;
        error_d=0.0;
	error_i=0.0;
	Ui_1_d=0.0;
	Ui_1_i=0.0;
	Ud_1_d=0.0;
	Ud_1_i=0.0;
	error_1_d=0.0;
	error_1_i=0.0;

	Up_d=0.0;
	Up_i=0.0;
	Ui_d=0.0;
	Ud_d=0.0;
	U_d=0.0;
	Ui_i=0.0;
	Ud_i=0.0;
	U_d=0.0;
	U_i=0.0;
	c=0.0;
	estado_ref=0.0;

        Ref << 0.0,0.0;
        Yt << 0.0,0.0,0.0,0.0,0.0;
        error << 0.0,0.0;
        error_1 << 0.0,0.0;
        Ut << 0.0,0.0;
        Ut_1 << 0.0,0.0;
        Ut_S << 0.0,0.0;
        Ui << 0.0,0.0;
        Ui_1 << 0.0,0.0;

	Xt_ref=espacio[estado_ref];
        Yaw_ref=angulo[estado_ref];
	Xt=0.0;
	yaw_1=0.0;
	yaw2=0.0;
	zz=0;
	c=0;
	}
	//--------------------- se alista un paquete y enviar al arduino --------------
	enviar[0]=77;
	RS232_SendBuf(cport_nr2,enviar,1);
	while(cadena==0)
	{
	n_cadena = RS232_PollComport(cport_nr2, buf_cadena,300);
	agrupar();
	}

	printf("Valores enviar por el Arduino Mega, valor cadena= %i, received=%i, contador datos=%i,  bytes: %s\n",cadena, n_cadena, cont_datos,buf_datos);
	for(i=0;i<10;i++)
	{
		entero[i]=0;
		decimal[i]=0;
	}
	decodificar();
	//---------------------- valores de la IMU Navio+ ------------------------------
	imu.getMotion9(&ax2, &ay2, &az2, &gx2, &gy2, &gz2, &mx2, &my2, &mz2);
	/*
	ax = ax*10;
	ay = ay*10;
	az = az*10;
	*/
	//--------------------- calculo de YAW ----------------------------------------
 	no_calibrated(0)=mx2;
    	no_calibrated(1)=my2;
    	no_calibrated(2)=mz2;

	calibrated = m*(no_calibrated-b);

	mx2=calibrated(0);
    	my2=calibrated(1);
    	mz2=calibrated(2);

	ahrs.update(ax2, ay2, az2, gx2*0.0175, gy2*0.0175, gz2*0.0175, my2, mx2, -mz2, dt);
	ahrs.getEuler(&roll, &pitch, &yaw);
	yaw = DEGREES_TO_RADIANS * yaw;
	//----------------------------------------------------------------------------
	printf("Acc: %+7.6f %+7.6f %+7.6f ", ax2, ay2, az2);
	printf("Gyr: %+8.6f %+8.6f %+8.6f ", gx2, gy2, gz2);
	printf("Mag: %+7.6f %+7.6f %+7.6f\n", mx2, my2, mz2);
	printf("ROLL: %+05.2f PITCH: %+05.2f YAW: %f PERIOD %.4fs RATE %dHz \n", roll, pitch, yaw, dt, int(1/dt));

	//---------------------- Valores de la IMU Advance Navigation -----------------
	//unidad_IMU();
	//---------------------- agrupar datos de sensores en una trama ---------------
	//conver(raw_sensors_packet.accelerometers[0],raw_sensors_packet.accelerometers[1],raw_sensors_packet.accelerometers[2],ax2,ay2,az2,euler_orientation_packet.orientation[0]*RADIANS_TO_DEGREES,euler_orientation_packet.orientation[1]*RADIANS_TO_DEGREES,euler_orientation_packet.orientation[2]*RADIANS_TO_DEGREES);
	printf("Trama junto a los valores de sensores Bytes: %s\n",buf_datos);
	//---------- se determina Modo (seguridad,RC,autonomo),almacena datos ---------
	printf("valor del la palanco del control %i\n",estado);

	if(estado == 0){
		if(estado_aux==2)
		{
		fclose(pFile);
		estado_aux=0;
		}
		if(estado_aux==4)
		{
		fclose(pFile);
		estado_aux=0;
		}
	}
	else if(estado==1){
		if(estado_aux==2)
		estado_aux=2;
		else if(estado_aux==4)
		{
		fclose(pFile);
		estado_aux=1;
		}
		else
		estado_aux=1;

//		if(pFile!=NULL && estado_aux==2)
//			fputs(buf_datos,pFile);
	}
	if(estado==2)
	{
		if(estado_aux==4)
		estado_aux=4;
		else if(estado_aux==2)
		{
		fclose(pFile);
		estado_aux=3;
		}
		else
		estado_aux=3;
	}
//		if(pFile!=NULL && estado_aux==4)
//			fputs(buf_datos,pFile);
//------------- imprimir el valor en los variadores ---------------------------
	if(estado_aux==4)
	{
//------------------ ALGORITMO TRAYECTORIA -------------------------------------------------------


//------------------------------------------------ correcion YAW
	if((yaw-yaw_1)>6)
	c=c-2;
	if((yaw-yaw_1)<-6)
	c=c+2;

	yaw2=yaw+c*M_PI;
//-------------------------------------------------

/*
	Xt = Xt + ((w_der+w_iz)/2.0)*0.2*0.06;
	Xt_ref=espacio[estado_ref];
        error(0) = Yaw_ref - yaw2;// Yaw
	error(1) = Xt_ref - Xt;


	if(abs(error(1))<0.5)
	{
		estado_ref=estado_ref+1;
		Xt_ref=espacio[estado_ref];
		Yaw_ref=angulo[estado_ref];
	}

	if(abs(error(0))<0.1745){
		Xt_ref=espacio[estado_ref];
	}else{
		error(1)=0;
	}
*/
// INICIO LQR

	theta=(w_der_a-w_iz_a)*0.2632*0.38*Ts+theta_a;

        Yt(0) = w_iz;
        Yt(1) = w_der;
//	Yt(2) = yaw2;
	Yt(2) = theta; //(w_der_1-w_iz_1)*0.2632*0.38*Ts+theta_1;
	Yt(3) = I_Iz;
	Yt(4) = I_Der;

	if(zz>250)
		rev_vel = 0.5;
	else
		rev_vel = 1.0;


	if(zz>367)
		rev_theta = (M_PI/2);
	else
		rev_theta=0.0;


	error(1) = rev_vel - ((w_der+w_iz)/2.0)*0.2;
	error(0) = rev_theta - yaw2;


	Yt_delta = Yt - Yt_1;
	Uk_s(0) = 50.0;
	Uk_s(1) = 50.0;
	Yt_1(0)=5.18;
	Yt_1(1)=5.33;
	Yt_1(2)=0.0;
	Yt_1(3)=2.25;
	Yt_1(4)=2.45;

/*
	Ref(0)= Yaw_ref;
	Ref(1) = Xt_ref;
*/
//	Ui = Ki*error_1+Ui_1-Kt*(Ut_S-Ut_1); //anti integral
	Ui = Ki*error_1+Ui_1+(Ut_1-Ut_S)/Kt; //anti integral
        Ut = -Uk_s-Ui-Kc*Yt_delta;
//	Ut = Ref-Kc*Yt;
        Ut_S = Ut;

//	Ut(0)=Ut(0)+50.0;
//	Ut(1)=Ut(1)+50.0;

	if(Ut(0)>100)
                Ut_S(0)=100;
        if(Ut(0)<-100)
                Ut_S(0)=-100;

        if(Ut(1)>100)
                Ut_S(1)=100;
        if(Ut(1)<-100)
                Ut_S(1)=-100;

	Ui_1=Ui;
        error_1=error;
        Ut_1=Ut;
        yaw_1=yaw;
	w_der_a=w_der;
	w_iz_a=w_iz;
	theta_a=theta;
//------------------ LQR Fin ----------------------------------------------------------

	U_d = Ut_S(1);
	U_i = Ut_S(0);

	motor_1 = U_d;
	motor_2 = U_i;
	// recordar de guardar Yaw2 o Yaw
	if(theta>999)
	theta = 999;
	if(theta<-999)
	theta = -999;
	conver(motor_1,motor_2,rev_vel,rev_theta,theta,0.0,0.0,999.999,theta);
	motor_1=map(motor_1,0,-100,1480,2300);
        motor_2=map(motor_2,0,-100,1480,2300);
        printf("imprimir PWM auto1= %i\n",motor_1);
        printf("impirmir PWM AUTO2= %i\n",motor_2);
//        pwm.setPWMmS(NAVIO_RCOUTPUT_1, motor_1/1000.0);
//        pwm.setPWMmS(NAVIO_RCOUTPUT_2, motor_2/1000.0);

	zz++;

nver_motor();
/*
	motor_1=map(motor_1,0,-100,1480,2300);
	motor_2=map(motor_2,0,-100,1480,2300);
	printf("imprimir PWM AUTO1= %i\n",motor_1);
	printf("impirmir PWM AUTO2= %i\n",motor_2);
	pwm.setPWMmS(NAVIO_RCOUTPUT_1, motor_1/1000.0);
	pwm.setPWMmS(NAVIO_RCOUTPUT_2, motor_2/1000.0);
*/
	}
	else
	{
	if((yaw-yaw_1)>6)
        c=c-2;
        if((yaw-yaw_1)<-6)
        c=c+2;

	yaw_1=yaw;
        yaw2=yaw+c*M_PI;

	conver(0.0,0.0,0.0,0.0,0.0,0.0,roll,pitch,yaw2);
	motor_1=map(motor_1,0,-100,1480,2300);
	motor_2=map(motor_2,0,-100,1480,2300);
	printf("imprimir PWM RC1= %i\n",motor_1);
	printf("imprimir PWM RC2= %i\n",motor_2);
//	pwm.setPWMmS(NAVIO_RCOUTPUT_1, motor_1/1000.0);
//	pwm.setPWMmS(NAVIO_RCOUTPUT_2, motor_2/1000.0);
	}


	if(telemetria > 10)
	{
	//---------- se agrupan todos los datos para almacenar USB y envio Telemtria ---
	//printf("todo agrupado para guardar bytes: %s  \n",buf_datos);
	inicio[0]=67;   // C
        inicio1[0]=58;  // :
	RS232_SendBuf(cport_nr3,inicio,1);      // linea inicio trama
        RS232_SendBuf(cport_nr3,inicio1,1);     //------------------------
	RS232_SendBuf(cport_nr3,(unsigned char *)buf_datos,cont_datos);
	enviar[0]=13;	// con este simbolo bajamos un reglon para una buena vizualizacion.
	RS232_SendBuf(cport_nr3,enviar,1);
	telemetria=0;
	}

	telemetria = telemetria + 1;
	//----------- guarda datos en la USB ----------------------------
	if(pFile!=NULL && estado_aux==2)
		fputs(buf_datos,pFile);
	if(pFile!=NULL && estado_aux==4)
		fputs(buf_datos,pFile);
	//----------- colocar valores en cero para no acumular datos basura ------------
	for(int z=0;z<249;z++)
	{
		buf_cadena[z]=0;
		buf_datos[z]=0;
	}
	cadena=0;
	cont_datos=0;
	cont=0;
	//-----------------------------------------------------------------------------
	//---------------------- fin de una ciclo -------------------------------------
	gettimeofday(&t_fin, NULL); // final del contador, para una iteracion.

	secs = timeval_diff(&t_fin, &t_ini);
    	while((secs*1000000.0)<Ts)
	{
    	gettimeofday(&t_fin,NULL);
	secs = timeval_diff(&t_fin, &t_ini);
	}

	printf("%.5g microsegundos\n", secs * 1000000.0);


}

	return 0;
}
